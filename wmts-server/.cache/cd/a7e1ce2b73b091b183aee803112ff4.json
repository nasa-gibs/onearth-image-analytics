{"id":"ugIk","dependencies":[{"name":"/Users/jaaustin/node_modules/ol/render/webgl/circlereplay/defaultshader.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/jaaustin/Documents/ml-gibs/package.json","includedInParent":true,"mtime":1559664405074},{"name":"/Users/jaaustin/node_modules/ol/package.json","includedInParent":true,"mtime":1559664113128},{"name":"../../../webgl.js","loc":{"line":7,"column":35},"parent":"/Users/jaaustin/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/Users/jaaustin/node_modules/ol/webgl.js"},{"name":"../../../webgl/Fragment.js","loc":{"line":8,"column":26},"parent":"/Users/jaaustin/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/Users/jaaustin/node_modules/ol/webgl/Fragment.js"},{"name":"../../../webgl/Vertex.js","loc":{"line":9,"column":24},"parent":"/Users/jaaustin/node_modules/ol/render/webgl/circlereplay/defaultshader.js","resolved":"/Users/jaaustin/node_modules/ol/webgl/Vertex.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.vertex=exports.fragment=void 0;var i=require(\"../../../webgl.js\"),e=o(require(\"../../../webgl/Fragment.js\")),t=o(require(\"../../../webgl/Vertex.js\"));function o(i){return i&&i.__esModule?i:{default:i}}var a=new e.default(i.DEBUG?\"precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n\":\"precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}\");exports.fragment=a;var n=new t.default(i.DEBUG?\"varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n\":\"varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;if(f==0.0){offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}\");exports.vertex=n;"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":0}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":13}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":20}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":35}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":43}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":56}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":57}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":64}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":68}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":76}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":83}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":91}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":105}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":7,"column":0},"generated":{"line":1,"column":107}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":7,"column":0},"generated":{"line":1,"column":111}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":7,"column":0},"generated":{"line":1,"column":113}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":7,"column":0},"generated":{"line":1,"column":121}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":8,"column":0},"generated":{"line":1,"column":142}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":8,"column":0},"generated":{"line":1,"column":144}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":8,"column":0},"generated":{"line":1,"column":146}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":8,"column":0},"generated":{"line":1,"column":154}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":9,"column":0},"generated":{"line":1,"column":185}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":9,"column":0},"generated":{"line":1,"column":187}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":9,"column":0},"generated":{"line":1,"column":189}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":9,"column":0},"generated":{"line":1,"column":197}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":226}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":235}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":237}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":240}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":247}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":250}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":252}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":263}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":265}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":266}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":274}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":11,"column":7},"generated":{"line":1,"column":277}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":11,"column":13},"generated":{"line":1,"column":281}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":11,"column":24},"generated":{"line":1,"column":283}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":11,"column":28},"generated":{"line":1,"column":287}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":11,"column":24},"generated":{"line":1,"column":289}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":11,"column":42},"generated":{"line":1,"column":297}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":12,"column":2},"generated":{"line":1,"column":299}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":12,"column":2},"generated":{"line":1,"column":305}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":13,"column":2},"generated":{"line":1,"column":1959}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":2862}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":2870}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":2879}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":2881}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":15,"column":13},"generated":{"line":1,"column":2885}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":15,"column":22},"generated":{"line":1,"column":2887}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":15,"column":26},"generated":{"line":1,"column":2891}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":15,"column":22},"generated":{"line":1,"column":2893}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":15,"column":38},"generated":{"line":1,"column":2901}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":16,"column":2},"generated":{"line":1,"column":2903}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":16,"column":2},"generated":{"line":1,"column":2909}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":null,"original":{"line":17,"column":2},"generated":{"line":1,"column":4571}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":5264}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":5272}},{"source":"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js","name":"const","original":{"line":15,"column":7},"generated":{"line":1,"column":5279}}],"sources":{"../../../../../src/ol/render/webgl/circlereplay/defaultshader.js":"/**\n * @module ol/render/webgl/circlereplay/defaultshader\n */\n// This file is automatically generated, do not edit.\n// Run `make shaders` to generate, and commit the result.\n\nimport {DEBUG as DEBUG_WEBGL} from '../../../webgl.js';\nimport WebGLFragment from '../../../webgl/Fragment.js';\nimport WebGLVertex from '../../../webgl/Vertex.js';\n\nexport const fragment = new WebGLFragment(DEBUG_WEBGL ?\n  'precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n' :\n  'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');\n\nexport const vertex = new WebGLVertex(DEBUG_WEBGL ?\n  'varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n' :\n  'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;if(f==0.0){offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');\n"},"lineCount":null}},"error":null,"hash":"0302bb9198d9e3e934e47ca287e75019","cacheData":{"env":{}}}